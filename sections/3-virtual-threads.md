<!-- .slide: data-background="img/background/current-station.jpg" data-background-color="black" data-background-opacity="0.5"-->

# Virtual Threads <!-- .element: class="stroke" -->

<https://www.pexels.com/photo/photo-of-train-station-1824169/> <!-- .element: class="attribution" -->

note:
**Time Elapsed:** `22:00`.

* The features I covered so far have been a part of Java for a while now.
* They were part of 'our journey so far'.
* I guess it's safe to say our current station is 'virtual threads'.
* Because it was made final in Java 21.

---

## Feature Status

<table style="font-size: 100%">
    <thead>
        <tr>
            <th>Java version</th>
            <th>Feature status</th>
            <th>JEP</th>
        </tr>
    </thead>
    <tbody>
        <tr class="greyed-out">
            <td><strong>19</strong></td>
            <td>Preview <br/></td>
            <td><a href="https://openjdk.java.net/jeps/425">JEP 425</a></td>
        </tr>        
        <tr class="greyed-out">
            <td><strong>20</strong></td>
            <td>Second preview <br/></td>
            <td><a href="https://openjdk.java.net/jeps/436">JEP 436</a></td>
        </tr>
        <tr>
            <td><strong>21</strong></td>
            <td>Final <br/></td>
            <td><a href="https://openjdk.java.net/jeps/444">JEP 444</a></td>
        </tr>
    </tbody>
</table>

---

## Virtual Thread

* lightweight thread implementation; <!-- .element: class="fragment fade-in-then-semi-out" -->
* no explicit mapping to an OS thread; <!-- .element: class="fragment fade-in-then-semi-out" -->
* intended to run only a single task over its lifetime; <!-- .element: class="fragment fade-in-then-semi-out" -->
<li class="fragment fade-in-then-semi-out">scheduled by the JVM to run on a <em>carrier thread</em>.

---

<!-- .slide: data-background="img/background/virtual-threads-graph.png" data-background-size="contain" data-background-color="black" -->

<https://medium.com/@viraj_63415/java-virtual-threads-and-enterprise-scalability-603fce70930d> <!-- .element: class="attribution" -->

note:

Each virtual thread can be associated with multiple Platform (or Carrier) Threads during its lifetime — one at a time though. (could also be a single one, by the way)
When a virtual thread executes multiple CPU operations, they may be executed by different carrier threads.

---

<!-- .slide: data-background="img/background/parallel-trains.jpg" data-background-color="black" data-background-opacity="0.8"-->

<https://www.pexels.com/photo/gray-trains-on-train-depot-near-buildings-14535103/> <!-- .element: class="attribution" -->

note:

Classic or platform threads are expensive to create and slow to start and stop.
Like passenger trains.

---

<!-- .slide: data-background="img/background/java-concurrency-in-practice.jpeg" data-background-size="contain" data-background-color="white" -->

---

<!-- .slide: data-background="img/background/many-taxis-taking-off.jpg" data-background-color="black" data-background-opacity="0.8"-->

[background image generated by leonardo.ai](https://leonardo.ai) <!-- .element: class="attribution" -->

note: 

In contrast, virtual threads are cheap to create and fast to start and stop.
Like taxis.

---

<!-- .slide: data-background="out/puml/platform-threads/platform-threads.puml.svg" data-background-color="#222" data-background-opacity="1.0" data-background-size="48%" -->

note:

When a platform thread performs I/O (like doing a database call or network request), it is blocked until the response comes in.
It is unnecessarily taking up resources during blocking.

---

<!-- .slide: data-background="out/puml/virtual-threads/virtual-threads.puml.svg" data-background-color="#222" data-background-opacity="1.0" data-background-size="70%" -->

note:

Virtual threads offer a huge improvement over platform threads by returning thet carrier thread to the pool when blocking.
This is the reason why the performance gain when using virtual threads will be especially large when your tasks do much I/O work.
In these situations, virtual threads can offer significantly *higher throughput*.

---

<!-- .slide: data-auto-animate" -->

### Modeling a Restaurant with ExecutorService

<pre data-id="restaurant-virtual-threads"><code class="java" data-trim data-line-numbers>
public class MultiWaiterRestaurant implements Restaurant {
    @Override
    public MultiCourseMeal announceMenu() throws ExecutionException, InterruptedException {
        Waiter grover = new Waiter("Grover");
        Waiter zoe = new Waiter("Zoe");
        Waiter rosita = new Waiter("Rosita");

        try (var executor = Executors.newFixedThreadPool(3)) {
            Future&lt;Course&gt; starter = executor.submit(() -> grover.announceCourse(CourseType.STARTER));
            Future&lt;Course&gt; main = executor.submit(() -> zoe.announceCourse(CourseType.MAIN));
            Future&lt;Course&gt; dessert = executor.submit(() -> rosita.announceCourse(CourseType.DESSERT));

            return new MultiCourseMeal(starter.get(), main.get(), dessert.get());
        }
    }
}
</code></pre>

---

<!-- .slide: data-auto-animate" -->

### Modeling a Restaurant with Virtual Threads

<pre data-id="restaurant-virtual-threads"><code class="java" data-trim data-line-numbers="8">
public class MultiWaiterRestaurant implements Restaurant {
    @Override
    public MultiCourseMeal announceMenu() throws ExecutionException, InterruptedException {
        Waiter grover = new Waiter("Grover");
        Waiter zoe = new Waiter("Zoe");
        Waiter rosita = new Waiter("Rosita");

        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            Future&lt;Course&gt; starter = executor.submit(() -> grover.announceCourse(CourseType.STARTER));
            Future&lt;Course&gt; main = executor.submit(() -> zoe.announceCourse(CourseType.MAIN));
            Future&lt;Course&gt; dessert = executor.submit(() -> rosita.announceCourse(CourseType.DESSERT));

            return new MultiCourseMeal(starter.get(), main.get(), dessert.get());
        }
    }
}
</code></pre>

---

### Pros ✅

<ul>
    <li class="fragment fade-in-then-semi-out" data-fragment-index="1">millions of threads can run;</li>
    <small class="fragment fade-in-then-semi-out" data-fragment-index="1">(allowing the <em>thread-per-request</em> style instead of the <em>thread-sharing</em> style)</small>
    <li class="fragment fade-in-then-semi-out">creating them and disposing of them is cheap and fast;</li>
    <li class="fragment fade-in-then-semi-out">better throughput with high number of concurrent I/O-heavy tasks.</li>
</ul>
<br/>
<br/>
<br/>

### Cons ❌

* pinned threads; <!-- .element: class="fragment fade-in-then-semi-out" -->
* thread-local variables don't perform well with many threads. <!-- .element: class="fragment fade-in" -->
<small class="fragment fade-in-then-semi-out">(the system property <code>jdk.traceVirtualThreadLocals</code> can help)</small>

note: 

**millions of threads can run**

Platform threads are limited in number, because each thread comes with a *stack* that consumes 1MB of memory by default (though the stack size can be user-configured).
Virtual threads' stacks are stored in Java's garbage-collected heap as *stack chunk* objects.
The stacks grow and shrink as the application runs, enabling the creation of millions of virtual threads.

Virtual threads also allow a *thread-per-request* style, eliminating the need for thread-sharing mechanisms such as *thread pooling*.
It can even be combined with the synchronous programming style that Java is famous for.
(as opposed to the asynchronous programming style we have leared in the past ten years with frameworks like RxJava, for example)

In a way, virtual threads are Java's definitive answer to both thread pooling and the asynchronous programming style.

**better throughput**

Because unlike platform threads, virtual threads release the underlying carrier thread when I/O is performed.
We saw this in the sequence diagram, and it results in better throughput when tasks are I/O-heavy.
(this also means that virtual threads will not significantly improve performance when tasks are CPU-heavy!)

**pinned threads**

There are two scenarios in which a virtual thread cannot be unmounted during blocking operations because it is pinned to its carrier:

* When it executes code inside a `synchronized` block or method, or;
* When it executes a native method or a foreign function.

...harming scalability in the process.

(!) You can mitigate this drawback by replacing `synchronized` blocks with `ReentrantLock`s or `CountDownLatch`es - using them won't cause the *thread pinning*.
This is because the `LockSupport` class now supports *parking* and *unparking* virtual threads. JEP 444 has more details on this.

**thread-local variables don't perform well with many threads**

* virtual threads *do* support (inheritable) thread-locals.
* but they should not be used to pool costly resources among multiple tasks.
* in fact, virtual threads should never be pooled, since each is intended to run only a single task over its lifetime.
* many thread-locals were removed from the `java.base` module in preparation for virtual threads in order to reduce memory footprint when running with millions of threads.
* in fact, a system property `jdk.traceVirtualThreadLocals` was added for this very purpose. When set to `true`, it triggers a stack trace whenever a virtual thread sets the value of any thread-local variable.

---

### What Drawbacks Are Amplified 
### Now That Virtual Threads Are Available?

<li class="fragment fade-in-then-semi-out"><code>ExecutorService</code> allows unrestricted patterns of concurrency;
<li class="fragment fade-in-then-semi-out">memory-intensity of thread-locals.

note: 

These drawbacks all have to do with the increase in thread count that virtual threads will cause. 

**ExecutorService allows unrestricted patterns of concurrency**

* it's very hard with ExecutorService to create relationships among tasks and subtasks
* but that's a valid use case that occurs quite often!
* But ExecutorService doesn't enforce any task structure
* In theory, one thread could create an ExecutorService, a second thread could submit work to it.
* And the threads which actually execute the work would have no relationship to either the first or second thread. 
* They are *one-way jumps*, just like the notorious `goto` statement from the `BASIC` language.
* If threads are spawned in an unstructured way, they are like the concurrent equivalent of `goto`!
* To conclude: **ExecutorService allows unrestricted patterns of concurrency.**
* And this only gets worse when more threads are involved.

**memory-intensity of thread-locals**

* virtual threads are plentiful and cheap enough to create for any concurrent unit-of-work.
* so there might be millions of them
* then, if each of those virtual threads has its own copy of thread-local variables, the memory footprint may be significant.

---

<!-- .slide: data-background="img/background/no-stamp.jpg" data-background-color="black" data-background-opacity="0.7"-->

## Is This The Final Station? <!-- .element: class="stroke" -->

<blockquote class="explanation"><strong>No.</strong> These drawbacks are exactly the reason why Java's concurrency journey is continuing.</blockquote>

<https://www.pexels.com/photo/wood-man-hands-love-3838318/> <!-- .element: class="attribution" -->
